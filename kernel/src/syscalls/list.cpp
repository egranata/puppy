// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// autogenerated by syscalls/genimply.do - DO NOT EDIT manually

#include <kernel/syscalls/manager.h>
#include <kernel/syscalls/types.h>
#include <kernel/libc/string.h>

extern syscall_response_t yield_syscall_handler();
extern syscall_response_t yield_syscall_helper(SyscallManager::Request&);
extern syscall_response_t sleep_syscall_handler(uint32_t arg1);
extern syscall_response_t sleep_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t exit_syscall_handler(uint8_t arg1);
extern syscall_response_t exit_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t halt_syscall_handler();
extern syscall_response_t halt_syscall_helper(SyscallManager::Request&);
extern syscall_response_t reboot_syscall_handler();
extern syscall_response_t reboot_syscall_helper(SyscallManager::Request&);
extern syscall_response_t sysinfo_syscall_handler(sysinfo_t* arg1,uint32_t arg2);
extern syscall_response_t sysinfo_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t getcurdir_syscall_handler(char* arg1,size_t* arg2);
extern syscall_response_t getcurdir_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t setcurdir_syscall_handler(const char* arg1);
extern syscall_response_t setcurdir_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t getpid_syscall_handler();
extern syscall_response_t getpid_syscall_helper(SyscallManager::Request&);
extern syscall_response_t fopen_syscall_handler(const char* arg1,uint32_t arg2);
extern syscall_response_t fopen_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fclose_syscall_handler(uint32_t arg1);
extern syscall_response_t fclose_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fdup_syscall_handler(uint32_t arg1,uint32_t arg2);
extern syscall_response_t fdup_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fread_syscall_handler(uint32_t arg1,uint32_t arg2,uint32_t arg3);
extern syscall_response_t fread_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t exec_syscall_handler(const char* arg1,char** arg2,char** arg3,uint32_t arg4,exec_fileop_t* arg5);
extern syscall_response_t exec_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t kill_syscall_handler(uint32_t arg1);
extern syscall_response_t kill_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fstat_syscall_handler(uint32_t arg1,uint32_t arg2);
extern syscall_response_t fstat_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fseek_syscall_handler(uint32_t arg1,uint32_t arg2);
extern syscall_response_t fseek_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t ftell_syscall_handler(uint16_t arg1,size_t* arg2);
extern syscall_response_t ftell_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fopendir_syscall_handler(uint32_t arg1);
extern syscall_response_t fopendir_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t freaddir_syscall_handler(uint16_t arg1,file_info_t* arg2);
extern syscall_response_t freaddir_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t getppid_syscall_handler();
extern syscall_response_t getppid_syscall_helper(SyscallManager::Request&);
extern syscall_response_t collect_syscall_handler(kpid_t arg1,process_exit_status_t* arg2);
extern syscall_response_t collect_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fioctl_syscall_handler(uint32_t arg1,uint32_t arg2,uint32_t arg3);
extern syscall_response_t fioctl_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fwrite_syscall_handler(uint32_t arg1,uint32_t arg2,uint32_t arg3);
extern syscall_response_t fwrite_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t prioritize_syscall_handler(kpid_t arg1,prioritize_target arg2,const exec_priority_t* arg3,exec_priority_t* arg4);
extern syscall_response_t prioritize_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t mapregion_syscall_handler(uint32_t arg1,uint32_t arg2);
extern syscall_response_t mapregion_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t unmapregion_syscall_handler(uint32_t arg1);
extern syscall_response_t unmapregion_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t setregionperms_syscall_handler(uint32_t arg1,uint32_t arg2);
extern syscall_response_t setregionperms_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t mount_syscall_handler(uint32_t arg1,const char* arg2);
extern syscall_response_t mount_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t unmount_syscall_handler(const char* arg1);
extern syscall_response_t unmount_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t collectany_syscall_handler(bool arg1,kpid_t* arg2,process_exit_status_t* arg3);
extern syscall_response_t collectany_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t clone_syscall_handler(uintptr_t arg1,exec_fileop_t* arg2);
extern syscall_response_t clone_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fdel_syscall_handler(const char* arg1);
extern syscall_response_t fdel_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t mkdir_syscall_handler(const char* arg1);
extern syscall_response_t mkdir_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t proctable_syscall_handler(process_info_t* arg1,size_t arg2);
extern syscall_response_t proctable_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t vmcheckreadable_syscall_handler(uintptr_t arg1,size_t arg2);
extern syscall_response_t vmcheckreadable_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t vmcheckwritable_syscall_handler(uintptr_t arg1,size_t arg2);
extern syscall_response_t vmcheckwritable_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t pipe_syscall_handler(size_t* arg1,size_t* arg2);
extern syscall_response_t pipe_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t mmap_syscall_handler(size_t arg1,int arg2);
extern syscall_response_t mmap_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t wait1_syscall_handler(uint16_t arg1,uint32_t arg2);
extern syscall_response_t wait1_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t fsinfo_syscall_handler(const char* arg1,filesystem_info_t* arg2);
extern syscall_response_t fsinfo_syscall_helper(SyscallManager::Request& req);
extern syscall_response_t checkfeatures_syscall_handler(feature_id_t* arg1);
extern syscall_response_t checkfeatures_syscall_helper(SyscallManager::Request& req);

void SyscallManager::sethandlers() {
	handle(1, yield_syscall_helper, false); 
	handle(2, sleep_syscall_helper, false); 
	handle(3, exit_syscall_helper, false); 
	handle(4, halt_syscall_helper, false); 
	handle(5, reboot_syscall_helper, false); 
	handle(6, sysinfo_syscall_helper, false); 
	handle(7, getcurdir_syscall_helper, false); 
	handle(8, setcurdir_syscall_helper, false); 
	handle(9, getpid_syscall_helper, false); 
	handle(10, fopen_syscall_helper, false); 
	handle(11, fclose_syscall_helper, false); 
	handle(12, fdup_syscall_helper, false); 
	handle(13, fread_syscall_helper, false); 
	handle(14, exec_syscall_helper, false); 
	handle(15, kill_syscall_helper, false); 
	handle(16, fstat_syscall_helper, false); 
	handle(17, fseek_syscall_helper, false); 
	handle(18, ftell_syscall_helper, false); 
	handle(19, fopendir_syscall_helper, false); 
	handle(20, freaddir_syscall_helper, false); 
	handle(21, getppid_syscall_helper, false); 
	handle(22, collect_syscall_helper, false); 
	handle(23, fioctl_syscall_helper, false); 
	handle(24, fwrite_syscall_helper, false); 
	handle(25, prioritize_syscall_helper, false); 
	handle(26, mapregion_syscall_helper, false); 
	handle(27, unmapregion_syscall_helper, false); 
	handle(28, setregionperms_syscall_helper, false); 
	handle(29, mount_syscall_helper, false); 
	handle(30, unmount_syscall_helper, false); 
	handle(31, collectany_syscall_helper, false); 
	handle(32, clone_syscall_helper, false); 
	handle(33, fdel_syscall_helper, false); 
	handle(34, mkdir_syscall_helper, false); 
	handle(35, proctable_syscall_helper, false); 
	handle(36, vmcheckreadable_syscall_helper, false); 
	handle(37, vmcheckwritable_syscall_helper, false); 
	handle(38, pipe_syscall_helper, false); 
	handle(39, mmap_syscall_helper, false); 
	handle(40, wait1_syscall_helper, false); 
	handle(41, fsinfo_syscall_helper, false); 
	handle(42, checkfeatures_syscall_helper, false); 
}

syscall_response_t yield_syscall_helper(SyscallManager::Request&) {
	return yield_syscall_handler();
}


syscall_response_t sleep_syscall_helper(SyscallManager::Request& req) {
	return sleep_syscall_handler((uint32_t)req.arg1);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t exit_syscall_helper(SyscallManager::Request& req) {
	return exit_syscall_handler((uint8_t)req.arg1);
}
static_assert(sizeof(uint8_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t halt_syscall_helper(SyscallManager::Request&) {
	return halt_syscall_handler();
}


syscall_response_t reboot_syscall_helper(SyscallManager::Request&) {
	return reboot_syscall_handler();
}


syscall_response_t sysinfo_syscall_helper(SyscallManager::Request& req) {
	return sysinfo_syscall_handler((sysinfo_t*)req.arg1,(uint32_t)req.arg2);
}
static_assert(sizeof(sysinfo_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t getcurdir_syscall_helper(SyscallManager::Request& req) {
	return getcurdir_syscall_handler((char*)req.arg1,(size_t*)req.arg2);
}
static_assert(sizeof(char*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(size_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t setcurdir_syscall_helper(SyscallManager::Request& req) {
	return setcurdir_syscall_handler((const char*)req.arg1);
}
static_assert(sizeof(const char*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t getpid_syscall_helper(SyscallManager::Request&) {
	return getpid_syscall_handler();
}


syscall_response_t fopen_syscall_helper(SyscallManager::Request& req) {
	return fopen_syscall_handler((const char*)req.arg1,(uint32_t)req.arg2);
}
static_assert(sizeof(const char*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fclose_syscall_helper(SyscallManager::Request& req) {
	return fclose_syscall_handler((uint32_t)req.arg1);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fdup_syscall_helper(SyscallManager::Request& req) {
	return fdup_syscall_handler((uint32_t)req.arg1,(uint32_t)req.arg2);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fread_syscall_helper(SyscallManager::Request& req) {
	return fread_syscall_handler((uint32_t)req.arg1,(uint32_t)req.arg2,(uint32_t)req.arg3);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t exec_syscall_helper(SyscallManager::Request& req) {
	return exec_syscall_handler((const char*)req.arg1,(char**)req.arg2,(char**)req.arg3,(uint32_t)req.arg4,(exec_fileop_t*)req.arg5);
}
static_assert(sizeof(const char*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(char**) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(char**) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(exec_fileop_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t kill_syscall_helper(SyscallManager::Request& req) {
	return kill_syscall_handler((uint32_t)req.arg1);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fstat_syscall_helper(SyscallManager::Request& req) {
	return fstat_syscall_handler((uint32_t)req.arg1,(uint32_t)req.arg2);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fseek_syscall_helper(SyscallManager::Request& req) {
	return fseek_syscall_handler((uint32_t)req.arg1,(uint32_t)req.arg2);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t ftell_syscall_helper(SyscallManager::Request& req) {
	return ftell_syscall_handler((uint16_t)req.arg1,(size_t*)req.arg2);
}
static_assert(sizeof(uint16_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(size_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fopendir_syscall_helper(SyscallManager::Request& req) {
	return fopendir_syscall_handler((uint32_t)req.arg1);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t freaddir_syscall_helper(SyscallManager::Request& req) {
	return freaddir_syscall_handler((uint16_t)req.arg1,(file_info_t*)req.arg2);
}
static_assert(sizeof(uint16_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(file_info_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t getppid_syscall_helper(SyscallManager::Request&) {
	return getppid_syscall_handler();
}


syscall_response_t collect_syscall_helper(SyscallManager::Request& req) {
	return collect_syscall_handler((kpid_t)req.arg1,(process_exit_status_t*)req.arg2);
}
static_assert(sizeof(kpid_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(process_exit_status_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fioctl_syscall_helper(SyscallManager::Request& req) {
	return fioctl_syscall_handler((uint32_t)req.arg1,(uint32_t)req.arg2,(uint32_t)req.arg3);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fwrite_syscall_helper(SyscallManager::Request& req) {
	return fwrite_syscall_handler((uint32_t)req.arg1,(uint32_t)req.arg2,(uint32_t)req.arg3);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t prioritize_syscall_helper(SyscallManager::Request& req) {
	return prioritize_syscall_handler((kpid_t)req.arg1,(prioritize_target)req.arg2,(const exec_priority_t*)req.arg3,(exec_priority_t*)req.arg4);
}
static_assert(sizeof(kpid_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(prioritize_target) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(const exec_priority_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(exec_priority_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t mapregion_syscall_helper(SyscallManager::Request& req) {
	return mapregion_syscall_handler((uint32_t)req.arg1,(uint32_t)req.arg2);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t unmapregion_syscall_helper(SyscallManager::Request& req) {
	return unmapregion_syscall_handler((uint32_t)req.arg1);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t setregionperms_syscall_helper(SyscallManager::Request& req) {
	return setregionperms_syscall_handler((uint32_t)req.arg1,(uint32_t)req.arg2);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t mount_syscall_helper(SyscallManager::Request& req) {
	return mount_syscall_handler((uint32_t)req.arg1,(const char*)req.arg2);
}
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(const char*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t unmount_syscall_helper(SyscallManager::Request& req) {
	return unmount_syscall_handler((const char*)req.arg1);
}
static_assert(sizeof(const char*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t collectany_syscall_helper(SyscallManager::Request& req) {
	return collectany_syscall_handler((bool)req.arg1,(kpid_t*)req.arg2,(process_exit_status_t*)req.arg3);
}
static_assert(sizeof(bool) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(kpid_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(process_exit_status_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t clone_syscall_helper(SyscallManager::Request& req) {
	return clone_syscall_handler((uintptr_t)req.arg1,(exec_fileop_t*)req.arg2);
}
static_assert(sizeof(uintptr_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(exec_fileop_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fdel_syscall_helper(SyscallManager::Request& req) {
	return fdel_syscall_handler((const char*)req.arg1);
}
static_assert(sizeof(const char*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t mkdir_syscall_helper(SyscallManager::Request& req) {
	return mkdir_syscall_handler((const char*)req.arg1);
}
static_assert(sizeof(const char*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t proctable_syscall_helper(SyscallManager::Request& req) {
	return proctable_syscall_handler((process_info_t*)req.arg1,(size_t)req.arg2);
}
static_assert(sizeof(process_info_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(size_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t vmcheckreadable_syscall_helper(SyscallManager::Request& req) {
	return vmcheckreadable_syscall_handler((uintptr_t)req.arg1,(size_t)req.arg2);
}
static_assert(sizeof(uintptr_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(size_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t vmcheckwritable_syscall_helper(SyscallManager::Request& req) {
	return vmcheckwritable_syscall_handler((uintptr_t)req.arg1,(size_t)req.arg2);
}
static_assert(sizeof(uintptr_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(size_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t pipe_syscall_helper(SyscallManager::Request& req) {
	return pipe_syscall_handler((size_t*)req.arg1,(size_t*)req.arg2);
}
static_assert(sizeof(size_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(size_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t mmap_syscall_helper(SyscallManager::Request& req) {
	return mmap_syscall_handler((size_t)req.arg1,(int)req.arg2);
}
static_assert(sizeof(size_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(int) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t wait1_syscall_helper(SyscallManager::Request& req) {
	return wait1_syscall_handler((uint16_t)req.arg1,(uint32_t)req.arg2);
}
static_assert(sizeof(uint16_t) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(uint32_t) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t fsinfo_syscall_helper(SyscallManager::Request& req) {
	return fsinfo_syscall_handler((const char*)req.arg1,(filesystem_info_t*)req.arg2);
}
static_assert(sizeof(const char*) <= sizeof(uint32_t), "type is not safe to pass in a register");
static_assert(sizeof(filesystem_info_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

syscall_response_t checkfeatures_syscall_helper(SyscallManager::Request& req) {
	return checkfeatures_syscall_handler((feature_id_t*)req.arg1);
}
static_assert(sizeof(feature_id_t*) <= sizeof(uint32_t), "type is not safe to pass in a register");

